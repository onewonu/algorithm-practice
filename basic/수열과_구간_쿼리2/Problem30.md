# 수열과 구간 쿼리 2
### 문제 설명
정수 배열 `arr`와 2차원 정수 배열 `queries`가 주어집니다.  
`queries`의 원소는 각각 하나의 query를 나타내며, `[s, e, k]` 꼴입니다.

각 query마다 순서대로 `s ≤ i ≤ e`인 모든 `i`에 대해 `k`보다 크면서 가장 작은 `arr[i]`를 찾습니다.

각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 solution 함수를 완성해 주세요.  
단, 특정 쿼리의 답이 존재하지 않으면 -1을 저장합니다.

### 제한사항
- 1 ≤ `arr`의 길이 ≤ 1,000
- 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
- 0 ≤ `s` ≤ `e` < `arr`의 길이
- 0 ≤ `k` ≤ 1,000,000

### 입출력 예

| arr             | queries                           | result     |
|-----------------|-----------------------------------|------------|
| [0, 1, 2, 4, 3] | [[0, 4, 2], [0, 3, 2], [0, 2, 2]] | [3, 4, -1] |

### 입출력 예 설명
#### 입출력 예 #1
- 첫 번째 쿼리 `[0, 4, 2]`: 범위에는 0, 1, 2, 4, 3이 있으며 이 중 `2`보다 크면서 가장 작은 값은 `3`입니다.
- 두 번째 쿼리 `[0, 3, 2]`: 범위에는 0, 1, 2, 4가 있으며 이 중 `2`보다 크면서 가장 작은 값은 `4`입니다.
- 세 번째 쿼리 `[0, 2, 2]`: 범위에는 0, 1, 2가 있으며 여기에는 `2`보다 큰 값이 없습니다.  
  따라서 `[3, 4, -1]`을 return 합니다.
# 회고
> int minVal = -1;
- minVal
  - 현재 쿼리에서 찾을 k보다 크면서 가장 작은 값을 저장할 변수 초기화.
> if (minVal == -1 || minVal > arr[j]) { minVal = arr[j]; }
- minVal == -1
  - 아직 minVal 이 초기값 -1을 유지하고 있다는 의미로, 이는 k보다 큰 값이 아직 발견되지 않았음을 나타내고, 첫 번째로 발견한 k보다 큰 값을 minVal 에 저장.
- minVal > arr[j]
  - 현재 발견된 값이 이전에 저장된 minVal 보다 더 작은 값인지를 확인하는 조건으로, k보다 큰 값들 중에서 더 작은 값이 있으면 minVal 을 갱신.
### Stream API
```java
import java.util.Arrays;

public int[] solution(int[] arr, int[][] queries) {
  return Arrays.stream(queries)
          .mapToInt(query ->
                  Arrays.stream(arr, query[0], query[1] + 1)
                          .filter(value -> value > query[2])  
                          .min()                              
                          .orElse(-1)                         
          )
          .toArray();
}
```