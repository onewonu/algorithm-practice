## 배열 만들기 6

### 문제 설명
0과 1로만 이루어진 정수 배열 `arr`가 주어집니다. `arr`를 이용해 새로운 배열 `stk`을 만드려고 합니다.

1. `i`의 초기값을 0으로 설정하고 `i`가 `arr`의 길이보다 작으면 다음을 반복합니다.
    - **조건 1:** `stk`이 빈 배열이라면 `arr[i]`를 `stk`에 추가하고 `i`에 1을 더합니다.
    - **조건 2:** `stk`에 원소가 있고, `stk`의 마지막 원소가 `arr[i]`와 같으면 `stk`의 마지막 원소를 `stk`에서 제거하고 `i`에 1을 더합니다.
    - **조건 3:** `stk`에 원소가 있는데 `stk`의 마지막 원소가 `arr[i]`와 다르면 `stk`의 맨 마지막에 `arr[i]`를 추가하고 `i`에 1을 더합니다.
2. 위 작업을 마친 후 만들어진 `stk`을 반환합니다.
3. 단, 만약 빈 배열을 반환해야 한다면 `[-1]`을 반환합니다.

---

### 제한사항
- $1 \leq arr \text{의 길이} \leq 1,000,000$
- `arr`의 원소는 0 또는 1입니다.

---

### 입출력 예

| `arr`             | `result`          |
|-------------------|-------------------|
| `[0, 1, 1, 1, 0]` | `[0, 1, 0]`       |
| `[0, 1, 0, 1, 0]` | `[0, 1, 0, 1, 0]` |
| `[0, 1, 1, 0]`    | `[-1]`            |

---

### 입출력 예 설명

#### 예제 #1
각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다.

| `idx` | `arr[idx]` | `stk`       |
|-------|------------|-------------|
| 0     | 0          | `[]`        |
| 1     | 1          | `[0]`       |
| 2     | 1          | `[0, 1]`    |
| 3     | 1          | `[0]`       |
| 4     | 0          | `[0, 1]`    |
| 5     | -          | `[0, 1, 0]` |

따라서 `[0, 1, 0]`을 반환합니다.

#### 예제 #2
각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다.

| `idx` | `arr[idx]` | `stk`             |
|-------|------------|-------------------|
| 0     | 0          | `[]`              |
| 1     | 1          | `[0]`             |
| 2     | 0          | `[0, 1]`          |
| 3     | 1          | `[0, 1, 0]`       |
| 4     | 0          | `[0, 1, 0, 1]`    |
| 5     | -          | `[0, 1, 0, 1, 0]` |

따라서 `[0, 1, 0, 1, 0]`을 반환합니다.

#### 예제 #3
각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다.

| `idx` | `arr[idx]` | `stk`       |
|-------|------------|-------------|
| 0     | 0          | `[]`        |
| 1     | 1          | `[0]`       |
| 2     | 1          | `[0, 1]`    |
| 3     | 0          | `[0]`       |
| 4     | -          | `[]`        |

마지막에 빈 배열이 되었으므로 `[-1]`을 반환합니다.
# 회고
### Stack
- Stack 클래스는 Vector 를 기반으로 구현되었으며, 동기화를 지원.
- 동기화를 제공하므로 멀티스레드 환경에서 안전하지만, 단일 스레드 환경에서는 불필요한 오버헤드가 발생할 수 있다.
- push(), pop(), peek() 메서드를 제공하며 직관적으로 스택 작업을 수행.
- 장점:
  - 간단하고 직관적인 API.
  - 특정한 스택 동작을 위해 만들어졌기 때문에 명시적으로 의도를 드러낼 수 있음.
- 단점:
  - 동기화 지원으로 인해 단일 스레드 환경에서 비효율적.
##### Stack 은 더 이상 Java Collections Framework 의 권장 구현체가 아님.
**1. 설계 문제**
- Stack 은 Vector 를 상속받는다.
  - Vector 는 동기화(synchronization)를 지원하는 리스트 구현체.
  - 현대의 대부분의 애플리케이션은 병렬 처리를 위해 동기화를 직접적으로 필요로 하지 않으며, Vector 의 동기화는 성능 저하를 유발할 수 있다.
- 스택 인터페이스를 따르지 않음
  - Stack 은 스택(LIFO) 동작을 위한 전용 인터페이스가 없다.
  - Stack 클래스는 List, Collection, Vector 인터페이스를 상속받아 LIFO 동작과 관련 없는 많은 메서드를 포함하고 있다.

**2. 성능 문제**
- 동기화된 메서드
  - Vector 기반의 Stack 은 모든 메서드가 동기화되어 있다.
  - 동기화된 메서드는 멀티스레드 환경에서 유용하지만, 단일 스레드 애플리케이션에서는 불필요한 오버헤드가 발생.
- 메모리 사용
  - Stack 및 Vector 는 내부적으로 동적 배열(dynamic array)을 사용하며, 배열 크기를 조정할 때 비용이 많이 들어간다.
### Deque
- 양방향 큐를 구현한 인터페이스.
- ArrayDeque, LinkedList 로 구현되며, Deque 를 사용해 스택뿐만 아니라 큐(FIFO)도 쉽게 구현할 수 있다.
- push(), pop(), peek() 메서드를 지원하므로 스택처럼 사용할 수 있다.
- 장점:
  - 스택과 큐를 모두 지원하므로 유연성이 높음.
  - 동기화를 제공하지 않아 단일 스레드 환경에서 성능이 더 좋음.
  - Java Collections Framework 의 권장 자료구조.
- 단점:
  - 스택의 명확한 의도를 나타내기엔 다소 모호할 수 있음(큐 동작도 지원하므로).

| **특징**     | **Stack**           | **Deque (ArrayDeque)**           |
|------------|---------------------|----------------------------------|
| **동기화**    | 동기화 지원              | 동기화 미지원                          |
| **성능**     | 단일 스레드 환경에서 더 느림    | 단일 스레드 환경에서 더 빠름                 |
| **유연성**    | 스택 전용               | 스택 및 큐로 모두 사용 가능                 |
| **메모리 사용** | 상대적으로 더 많은 메모리를 사용함 | 상대적으로 더 적은 메모리를 사용함              |
| **권장 여부**  | 현재는 권장하지 않음         | Java Collections Framework 에서 권장 |

### Reference
[java 21 docs: Stack](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Stack.html)
[java 21 docs:Deque](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Deque.html)