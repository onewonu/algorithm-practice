## 순서 바꾸기

### 문제 설명
정수 리스트 `num_list`와 정수 `n`이 주어질 때,  
`num_list`를 **n 번째 원소 이후의 원소들**과 **n 번째까지의 원소들**로 나누고,  
이후의 원소들을 앞부분에 붙인 리스트를 반환하는 `solution` 함수를 작성하세요.

---

### 제한사항
- $2 \leq \text{num_list의 길이} \leq 30$
- $1 \leq \text{num_list의 원소} \leq 9$
- $1 \leq n \leq \text{num_list의 길이}$

---

### 입출력 예

| num_list        | n | result          |
|-----------------|---|-----------------|
| [2, 1, 6]       | 1 | [1, 6, 2]       |
| [5, 2, 1, 7, 5] | 3 | [7, 5, 5, 2, 1] |

---

### 입출력 예 설명

#### 예제 #1
**리스트 분리**:
  - `n = 1` → n 번째 이후의 원소: `[1, 6]`.
  - n 번째까지의 원소: `[2]`.
**병합**:
  - `[1, 6] + [2] = [1, 6, 2]`.

#### 예제 #2
**리스트 분리**:
  - `n = 3` → n 번째 이후의 원소: `[7, 5]`.
  - n 번째까지의 원소: `[5, 2, 1]`.
**병합**:
  - `[7, 5] + [5, 2, 1] = [7, 5, 5, 2, 1]`.
# 회고
### 다른 사람의 풀이
```java
public int[] solution(int[] num_list, int n) {
    return IntStream.range(0, num_list.length)
            .map(i -> num_list[(i + n) % num_list.length])
            .toArray();
}
```
**순서**
- IntStream.range(0, num_list.length)
  - 0부터 num_list.length - 1까지의 정수 스트림을 생성.
  - 배열의 각 인덱스를 순회하기 위한 범위를 만든다.
- .map(i -> num_list[(i + n) % num_list.length]):
  - 각 i에 대해, **(i + n) % num_list.length**를 계산하여 원본 배열의 새로운 위치를 찾아낸다.
  - 이 식은 배열을 순환하며 새 인덱스를 결정.
    - i + n:
      - 원래 인덱스 i에 이동할 만큼의 값 n을 더한다.
    - % num_list.length:
      - 배열의 길이로 나눈 나머지를 사용하여 인덱스를 배열 범위 안으로 제한.
      - 이는 배열의 끝을 넘어서는 값이 처음으로 순환되도록 보장.
- .toArray():
  - 스트림에서 변환된 값을 배열로 수집하여 최종 결과를 반환.
**(i + n) \% num_list.length**
- 배열 범위를 초과하지 않도록 순환.
- 나머지 연산(%)은 값이 범위를 벗어날 때 순환하는 효과를 만들 수 있다.
- ex)
  - i = 0 :  (0 + 3) \% 5 = 3
  - i = 1 :  (1 + 3) \% 5 = 4
  - i = 2 :  (2 + 3) \% 5 = 0
  - i = 3 :  (3 + 3) \% 5 = 1
  - i = 4 :  (4 + 3) \% 5 = 2