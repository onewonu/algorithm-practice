## 무작위로 K개의 수 뽑기

### 문제 설명
랜덤으로 서로 다른 `k`개의 수를 저장한 배열을 만드려고 합니다.  
적절한 방법이 떠오르지 않기 때문에 일정한 범위 내에서 무작위로 수를 뽑은 후,  
지금까지 나온 적이 없는 수이면 배열 맨 뒤에 추가하는 방식으로 만들기로 합니다.

이미 어떤 수가 무작위로 주어질지 알고 있다고 가정하고, 실제 만들어질 길이 `k`의 배열을 예상해봅시다.

정수 배열 `arr`가 주어집니다. 문제에서의 무작위의 수는 `arr`에 저장된 순서대로 주어질 예정이라고 했을 때,  
완성될 배열을 return 하는 `solution` 함수를 완성해 주세요.

단, 완성될 배열의 길이가 `k`보다 작으면 나머지 값을 전부 `-1`로 채워서 return 합니다.

---

### 제한사항
- $1 \leq \text{arr의 길이} \leq 100,000$
- $0 \leq \text{arr의 원소} \leq 100,000$
- $1 \leq k \leq 1,000$

---

### 입출력 예

| arr                  | k | result           |
|----------------------|---|------------------|
| `[0, 1, 1, 2, 2, 3]` | 3 | `[0, 1, 2]`      |
| `[0, 1, 1, 1, 1]`    | 4 | `[0, 1, -1, -1]` |

---

### 입출력 예 설명

#### 예제 #1
- 앞에서부터 서로 다른 `k`개의 수를 골라내면 `[0, 1, 2]`가 됩니다.
- 따라서 `[0, 1, 2]`를 return 합니다.

#### 예제 #2
- 서로 다른 수의 개수가 2개 뿐이므로 서로 다른 수들을 앞에서부터 차례대로 저장한 `[0, 1]`에서  
  이후 2개의 인덱스를 `-1`로 채워넣은 `[0, 1, -1, -1]`을 return 합니다.
# 회고
### LinkedHashSet
- 특징  
  - Java 에서 제공하는 Set Interface 의 구현체로, 중복 없는 원소를 유지하면서 삽입 순서를 보장한다
  - 중복 여부 판단은 hashCode, equals 메서드로 판단
  - 내부적으로 Linked List 와 Hash Table 을 조합하여 구현
  - 추가, 삭제, 포함 여부 확인: 평균적으로 $O(1)$
  - null 허용
- 주요 메서드
  - add(E e): 요소를 추가. 이미 존재하면 추가하지 않음
  - remove(Object o): 특정 요소 제거
  - contains(Object o): 특정 요소가 존재하는지 확인
  - clear(): 모든 요소 제거
  - isEmpty(): 비어 있는지 확인
  - iterator(): 순회 가능한 Iterator 반환
### Reference
[java 21 docs: LinkedHashSet](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashSet.html)