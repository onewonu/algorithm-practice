# 배열 조각하기

## 문제 설명
정수 배열 `arr`와 `query`가 주어집니다.  
`query`를 순회하며 다음 작업을 반복합니다:

1. **짝수 인덱스(`i`)**:
    - `arr`에서 `query[i]`번 인덱스를 제외하고  
      배열의 **`query[i]`번 인덱스 뒷부분**을 잘라 버립니다.

2. **홀수 인덱스(`i`)**:
    - `arr`에서 `query[i]`번 인덱스를 제외하고  
      배열의 **`query[i]`번 인덱스 앞부분**을 잘라 버립니다.

작업을 완료한 후 남은 `arr`를 반환하세요.

---

## 제한사항
- $5 \leq \text{arr의 길이} \leq 100,000$
- $0 \leq \text{arr의 원소} \leq 100$
- $1 \leq \text{query의 길이} < \min(50, \text{arr의 길이} / 2)$
- $0 \leq \text{query의 각 원소} < \text{남아있는 arr의 길이}$

---

## 입출력 예

| arr                | query     | result    |
|--------------------|-----------|-----------|
| [0, 1, 2, 3, 4, 5] | [4, 1, 2] | [1, 2, 3] |

---

## 입출력 예 설명

### 예제 #1

| query의 값 | query 처리 전         | query 처리 후      | 비고                 |
|----------|--------------------|-----------------|--------------------|
| 4        | [0, 1, 2, 3, 4, 5] | [0, 1, 2, 3, 4] | **짝수 인덱스**: 뒷부분 제거 |
| 1        | [0, 1, 2, 3, 4]    | [1, 2, 3, 4]    | **홀수 인덱스**: 앞부분 제거 |
| 2        | [1, 2, 3, 4]       | [1, 2, 3]       | **짝수 인덱스**: 뒷부분 제거 |

따라서 `[1, 2, 3]`을 반환합니다.
# 회고
### 초기화
- start
  - 현재 남은 배열의 시작 인덳스 추적.
- end
  - (현재 남은 배열의 끝 + 1) 인덱스를 추적. 
  - 초기 상태에서는 배열의 모든 요소가 포함되므로 끝 인덱스는 배열의 전체 길이를 할당.
### 잘라내기: 뒷부분
- 짝수 인덱스는 뒷부분을 잘라낸다.
- 범위는 start 로 시작하여 query[i] 인덱스까지 포함해야 한다.
- copyOfRange 의 종료인덱스 미포함으로 인한 (end + 1)
### 잘라내기: 앞부분
- 홀수 인덱스는 앞부분을 잘라낸다.
- 범위는 query[i] 인덱스 이후.
- start 는 이전 시작 위치를 포함하고 있음으로 누적한다.
### Reference
[java 21 docs: Arrays.copyOfRange(int[],int,int)](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Arrays.html#copyOfRange(int[],int,int))