# 수열과 구간 쿼리 3
### 문제 설명
정수 배열 `arr`와 2차원 정수 배열 `queries`가 주어집니다.  
`queries`의 원소는 각각 하나의 query를 나타내며, `[i, j]` 꼴입니다.

각 query마다 순서대로 `arr[i]`의 값과 `arr[j]`의 값을 서로 바꿉니다.

위 규칙에 따라 `queries`를 처리한 이후의 `arr`를 return 하는 solution 함수를 완성해 주세요.

### 제한사항
- 1 ≤ `arr`의 길이 ≤ 1,000
- 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
- 0 ≤ `i` < `j` < `arr`의 길이

### 입출력 예

| arr             | queries                  | result          |
|-----------------|--------------------------|-----------------|
| [0, 1, 2, 3, 4] | [[0, 3], [1, 2], [1, 4]] | [3, 4, 1, 0, 2] |

### 입출력 예 설명
#### 입출력 예 #1
각 쿼리에 따라 `arr`가 다음과 같이 변합니다.

1. 초기 상태: [0, 1, 2, 3, 4]
2. 첫 번째 쿼리 [0, 3]에 따라 0번과 3번 인덱스 값을 교환: [3, 1, 2, 0, 4]
3. 두 번째 쿼리 [1, 2]에 따라 1번과 2번 인덱스 값을 교환: [3, 2, 1, 0, 4]
4. 세 번째 쿼리 [1, 4]에 따라 1번과 4번 인덱스 값을 교환: [3, 4, 1, 0, 2]

따라서 `[3, 4, 1, 0, 2]`를 return 합니다.
# 회고
### 잘못된 요구사항 분석으로 인한 구현
```java
public int[] solution(int[] arr, int[][] queries) {
    int[] answer = {};

    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < queries.length; j++) {
            int first = queries[j][0];
            int second = queries[j][1];

            if (arr[i] == first) {
                arr[i] = second;
            } else if (arr[i] == second) {
                arr[i] = first;
            }
        }
    }

    return arr;
}
```
#### 문제점
1. **값 기반 비교 및 변경:** 문제에서는 인덱스에 있는 값을 교환해야 하지만, 이 코드는 값을 비교하고 변경하려고 하여 잘못된 동작을 유발.
2. **인덱스 기반 교환 누락:** queries 에서 주어진 인덱스 i와 j에 해당하는 값을 단순히 교환하면 되지만, 코드에서는 인덱스가 아닌 값을 가지고 불필요한 비교와 조건 처리.
3. **값 처리 문제:** 배열 내에 같은 값이 여러 개 있을 경우, 이 방식으로는 동일한 값들이 잘못된 교환이 이루어질 수 있다.
#### 요구사항 해석
- `queries`의 원소는 각각 하나의 query를 나타내며, `[i, j]` 꼴입니다.
  - arr 의 인덱스를 나타낸다. 
  - arr 가 어떤 값인지 상관 없다.
- 0 ≤ `i` < `j` < `arr`의 길이
  - i와 j가 배열 arr 의 인덱스 범위 내에 있어야 하며, i는 항상 j보다 작은 인덱스여야 한다
  - 예를 들어 [[0, 5], [1, 1]]
    - [0, 5] 는 i < j 조건을 만족하지만, j < arr의 길이 조건을 만족하지 않는다.
    - [1, 1] i < j 조건을 만족하지 않는다.  
    - 
**queries 의 내부 배열에 선언된 두 인덱스 값에 해당하는 배열 arr 의 요소들을 교환하는 것이 요구사항.**