## 문자열 잘라서 정렬하기

### 문제 설명
문자열 `myString`이 주어집니다. `"x"`를 기준으로 해당 문자열을 잘라내 배열을 만든 후 **사전순으로 정렬한 배열**을 return 하는 `solution` 함수를 완성해 주세요.

단, 빈 문자열은 반환할 배열에 넣지 않습니다.

---

### 제한사항
- $1 \leq \text{myString의 길이} \leq 100,000$
- `myString`은 알파벳 소문자로 이루어진 문자열입니다.

---

### 입출력 예

| myString          | result                    |
|-------------------|---------------------------|
| `"axbxcxdx"`      | `["a","b","c","d"]`       |
| `"dxccxbbbxaaaa"` | `["aaaa","bbb","cc","d"]` |

---

### 입출력 예 설명

#### 예제 #1
- `myString`을 `"x"`를 기준으로 자르면 `["a","b","c","d"]`가 됩니다.
- 이 배열은 이미 사전순으로 정렬된 상태입니다.
- 따라서 `["a","b","c","d"]`를 return 합니다.

#### 예제 #2
- `myString`을 `"x"`를 기준으로 자르면 `["d","cc","bbb","aaaa"]`가 됩니다.
- 이를 사전순으로 정렬하면 `["aaaa","bbb","cc","d"]`가 됩니다.
- 따라서 `["aaaa","bbb","cc","d"]`를 return 합니다.
# 회고
### toArray 메서드의 두 가지 형태
**Object[] toArray()**
- 이 방식은 결과를 항상 Object[] 타입의 배열로 반환.
- 반환된 배열을 String[] 등으로 캐스팅해야 하며, 이는 타입 안정성이 떨어질 수 있다.

**<T> T[] toArray(T[] a)**
- 이 방식은 지정한 타입의 배열을 반환.
- 크기가 충분히 큰 배열을 제공하면 그 배열을 재사용하고, 그렇지 않으면 새로운 배열을 생성.
- 매개변수로 전달된 배열(a)의 크기에 따라 두 가지 방식으로 동작
  1. 전달된 배열이 컬렉션 크기와 같거나 더 클 경우: 해당 배열에 데이터를 채우고, 반환.
  2. 전달된 배열이 컬렉션 크기보다 작을 경우: 컬렉션의 크기에 맞는 새로운 배열을 생성하여 데이터를 복사한 후 반환.
     - new String[0]은 크기가 0인 빈 배열을 생성한다.
     - 전달된 배열 크기가 작기 때문에 컬렉션의 크기에 맞는 배열을 생성하여 데이터를 채운다.
### 다른 방법: Stream API
```java
import java.util.Arrays;

public String[] solution(String myString) {
    return Arrays.stream(myString.split("x"))
                 .filter(s -> !s.isEmpty()) 
                 .sorted() 
                 .toArray(String[]::new);
}
```